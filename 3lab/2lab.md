# Лабораторные работы по программированию: структура и реализация

## Темы лабораторных работ

1. Задача коммивояжёра
2. Шифрование данных
3. Нечеткий поиск
4. Бинаризация изображений
5. Брутфорс (метод перебора)
6. Парсинг сайта и построение графа

## Этапы реализации каждой лабораторной работы

2. Базовая реализация с использованием HTTP-протоколов (GET, POST)
3. Интеграция веб-сокетов для real-time взаимодействия
4. Внедрение Redis и Celery для асинхронного выполнения задач

## Общие требования к проектам

- Использование FastAPI в качестве веб-фреймворка
- SQLite как база данных
- SQLAlchemy для ORM (Object-Relational Mapping)
- Реализация авторизации по email и паролю
- Аутентификация с использованием JWT (JSON Web Tokens)

## Структура проекта

project/<br>
├── app/<br>
│   ├── api/           # эндпоинты<br>
│   ├── core/          # config <br>
│   ├── db/            # файл базы данных и сессия подключения <br>
│   ├── models/        # модели для базы данных<br>
│   ├── cruds/         # ORM CRUD операции<br>
│   ├── schemas/       # схемы запросов <br>
│   └── services/      # доп. сервисы, в нашем случае тут будет лежать логика 
├── main.py<br>
├── alembic/<br>
└── .env<br>

## Базовые эндпоинты

### Регистрация нового пользователя
@router.post("/sign-up/")
Проверяет, не зарегистрирован ли уже пользователь с таким email.
Если нет, создает нового пользователя и генерирует для него токен.
Возвращает данные созданного пользователя.

Пример запроса:<br>
{<br>
"email": "user@example.com",<br>
"password": "securepassword123"<br>
}<br>
Пример ответа:<br>
{<br>
"id": 1,<br>
"email": "user@example.com",<br>
"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."<br>
}

### Вход в систему
@router.post("/login/")
Проверяет существование пользователя с указанным email.
Проверяет правильность введенного пароля.
Если все верно, генерирует новый токен для пользователя.
Возвращает данные пользователя с новым токеном.

Пример запроса:<br>
{<br>
"email": "user@example.com",<br>
"password": "securepassword123"<br>
}<br>
Пример ответа:<br>
{<br>
"id": 1,<br>
"email": "user@example.com",<br>
"token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."<br>
}


### Получение информации о текущем пользователе
@router.get("/users/me/")
Возвращает данные авторизованного пользователя.

Пример ответа:<br>
{<br>
"id": 1,<br>
"email": "user@example.com"<br>
}

Данные о пользователе должны сохраняться в базу данных для чего вам надо написать CRUD'ы.
Необходимо пользоваться alembic для миграции базы данных.

## Вариант 1. Задача коммивояжёра (Этап 1)

Задача коммивояжёра (или TSP от англ. travelling salesman problem) — одна из самых известных задач комбинаторной оптимизации, заключающаяся в поиске самого выгодного маршрута, проходящего через указанные города ровно по одному разу с последующим возвратом в исходный город.

[К ознакомлению]( https://inzhenerka.tech/blog/tpost/k722n4lty1-kak-reshit-zadachu-kommivoyazhyora-metod#:~:text=%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D0%B2%D0%BE%D1%8F%D0%B6%D1%91%D1%80%D0%B0%20(Travelling%20Salesman%20Problem,%D1%81%D1%83%D0%BC%D0%BC%D0%B0%D1%80%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5%20%D0%B8%D0%BB%D0%B8%20%D1%81%D1%82%D0%BE%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D0%BF%D0%BE%D0%B5%D0%B7%D0%B4%D0%BA%D0%B8. )

### Эндпоинты:
@app.post("/shortest-path/", response_model=PathResult)
Принимает проиндексированный граф следующего вида (Граф должен быть описан в виде схемы в Pydantic и называться Graph):

{<br>
  "graph": {<br>
    "nodes": [1, 2, 3, 4],<br>
    "edges": [[1, 2], [2, 3], [3, 4], [1, 4]]<br>
  }<br>
}

Ответ должен быть следующим в виде схемы PathResult:

{<br>
  "path": [1, 2, 3, 4],<br>
  "total_distance": 4.0<br>
}

Path это путь, а total_distance это дистанция (len(path)).

## Вариант 2. Шифрование (Этап 1)

### 1. Хаффманическое сжатие данных

Алгоритм Хаффмана — жадный алгоритм оптимального префиксного кодирования алфавита с минимальной избыточностью. Был разработан в 1952 году аспирантом Массачусетского технологического института Дэвидом Хаффманом при написании им курсовой работы[1]. В настоящее время используется во многих программах сжатия данных.

[К ознакомлению](https://habr.com/ru/articles/144200/)

### 2. XOR-Шифрование

Алгоритм xor-шифрования является одним из самых простых линейных симметричных алгоритмов шифрования. Работа алгоритма заключается в последовательном цикличном кодировании символов входной последовательности с символами шифр-ключа с помощью операции сложения по модулю 2 (⊕), иными словами — исключающего ИЛИ (XOR).

[К ознакомлению](https://cmcmsu.info/1course/xor.coding.algs.htm)

### Эндпоинты:

@app.post("/encode", response_model=EncodeResponse)<br>
Принимает текст, сжимает его методом Хаффмана, шифрует XOR и возвращает зашифрованные данные, ключ, коды Хаффмана и информацию о паддинге.

Пример запроса:<br>
{<br>
"text": "Hello, World!",<br>
"key": "secret"<br>
}<br>
Пример ответа:<br>
{<br>
"encoded_data": "base64_encoded_string",<br>
"key": "secret",<br>
"huffman_codes": {"H": "00", "e": "01", "...": "..."},<br>
"padding": 3<br>
}

@app.post("/decode")<br>
Принимает зашифрованные данные, ключ, коды Хаффмана и информацию о паддинге, затем расшифровывает и распаковывает данные.

Пример запроса:<br>
{<br>
"encoded_data": "base64_encoded_string",<br>
"key": "secret",<br>
"huffman_codes": {"H": "00", "e": "01", "...": "..."},<br>
"padding": 3<br>
}<br>
Пример ответа:<br>
{<br>
"decoded_text": "Hello, World!"<br>
}

## Вариант 3. Нечеткий поиск (Этап 1)
Алгоритмы нечеткого поиска (также известного как поиск по сходству или fuzzy string search) являются основой систем проверки орфографии и полноценных поисковых систем вроде Google или Yandex. Например, такие алгоритмы используются для функций наподобие «Возможно вы имели в виду …» в тех же поисковых системах.
[К ознакомлению](https://habr.com/ru/articles/114997/)

Выберите и реализуйте 2 алгоритма нечеткого поиска из списка:
- Расстояние Левенштейна
- Расстояние Дамерау-Левенштейна
- Алгоритм Bitap с модификациями от Wu и Manber
- Алгоритм расширения выборки
- Метод N-грамм
- Хеширование по сигнатуре
- BK-деревья

### Эндпоинты:

@app.post("/upload_corpus")<br>
Загружает корпус текста для индексации и поиска.

Пример запроса:<br>
{<br>
"corpus_name": "example_corpus",<br>
"text": "This is a sample text for the corpus."<br>
}<br>
Пример ответа:<br>
{<br>
"corpus_id": 1,<br>
"message": "Corpus uploaded successfully"<br>
}


@app.get("/corpuses")<br>
Возвращает список корпусов c идентификаторами.

Пример ответа:<br>
{<br>
"corpuses": [<br>
  {"id": 1, "name": "example_corpus"},<br>
  {"id": 2, "name": "another_corpus"}<br>
]<br>
}<br>

@app.post("/search_algorithm")<br>
Позволяет указать слово (для поиска), тип алгоритма (которым можно искать), корпус (который можно использовать) и возвращает время работы алгоритма + результат поиска.

Пример запроса:<br>
{<br>
"word": "example",<br>
"algorithm": "levenshtein",<br>
"corpus_id": 1<br>
}<br>
Пример ответа:<br>
{<br>
"execution_time": 0.0023,<br>
"results": [<br>
  {"word": "example", "distance": 0},<br>
  {"word": "sample", "distance": 2}<br>
]<br>
}

## Вариант 4. Бинаризация изображения (Этап 1)
Процесс бинаризации – это перевод цветного (или в градациях серого) изображения в двухцветное черно-белое. Главным параметром такого преобразования является порог t – значение, с которым сравнивается яркость каждого пикселя. По результатам сравнения, пикселю присваивается значение 0 или 1.
[К ознакомлению](https://habr.com/ru/articles/278435/)

Выберите алгоритм пороговой обработки из предложенного списка.
Алгоритм сбалансированного порогового отсечения гистограммы:
  1) Алгоритм глобальной бинаризации с критерием Отсу.
  2) Алгоритм адаптивной бинаризации Бернсена.
  3) Алгоритм адаптивной бинаризации Брэдли и Рота.
  4) Алгоритм адаптивной бинаризации Эйквил.
  5) Алгоритм адаптивной бинаризации Ниблэка
  6) Алгоритм адаптивной бинаризации Саувола.
  7) Алгоритм адаптивной бинаризации WAN.
  8) Алгоритм адаптивной бинаризации Сингха.
  9) Алгоритм адаптивной бинаризации Вульфа.
  10) Алгоритм адаптивной бинаризации Феня и Тана.
  11) Алгоритм адаптивной бинаризации NICK.

### Эндпоинты:
@app.post("/binary_image")<br>
Дает возможность загрузить изображение в формате строки base64. Должно вернуть бинаризованное изображение в том же формате.

Пример запроса:<br>
{<br>
"image": "base64_encoded_image_string",<br>
"algorithm": "otsu"<br>
}<br>
Пример ответа:<br>
{<br>
"binarized_image": "base64_encoded_binarized_image_string"<br>
}

## Вариант 5. Брутфорс (Этап 1)
Полный перебор (или метод «грубой силы», англ. brute force) — метод решения математических задач. Относится к классу методов поиска решения исчерпыванием всевозможных вариантов[англ.]. Сложность полного перебора зависит от количества всех возможных решений задачи. Если пространство решений очень велико, то полный перебор может не дать результатов в течение нескольких лет или даже столетий.<br>
[К ознакомлению](https://habr.com/ru/companies/otus/articles/846872/)


Для начала попробуем разработать алгорим брутфорса
своими средствами.
Ломать будем пароленный rar-архив.

Алгоритм будет состоять из нескольких этапов. 
1) Извлечения хеша из RAR-архива (можно использовать сторонние библиотеки, к примеру rar2john из набора John the Ripper)
2) Определяемся со словарем из символов, которые потенциально могут быть в пароле, а также с его максимальной длиной.
3) Сгенерировать все возможные пароли и занести их в файл.
4) Осуществить эффективную брутфорс атаку на хеш архива.

### Эндпоинты:

@app.post("/brut_hash")<br>
Принимает хеш, словарь, максимальное количество символов (с ограничением в 8) и возвращает id задачи.

{<br>
  "hash": "строка с хешем RAR-архива",<br>
  "charset": "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",<br>
  "max_length": 8<br>
}

Возвращает:<br>
{<br>
  "task_id": "уникальный идентификатор задачи"<br>
}

@app.get("/get_status")<br>
Принимает id и возвращает статус задачи.<br>
Возвращает:<br>
{<br>
  "status": "running/completed/failed",<br>
  "progress": 45,<br>
  "result": "найденный пароль или null"<br>
}

## Вариант 6. Парсинг сайта и построение графа

Задача заключается в создании инструмента для парсинга веб-сайта, извлечения всех URL-путей и построения графа структуры сайта в стандартном формате.

### Описание функциональности:

1. Парсинг начинается с указанного URL и рекурсивно обходит все внутренние ссылки до заданной глубины.
2. Каждая уникальная страница становится узлом в графе, а ссылки между страницами - рёбрами.
3. Результирующий граф сохраняется в выбранном формате (например, GraphML).

[К ознакомлению](https://habr.com/ru/articles/579336/)

### Формат графа:

Рекомендуется использовать формат GraphML для представления структуры сайта. 



### Эндпоинты:

@app.post("/parse_website")

Принимает URL сайта для парсинга. Возвращает идентификатор задачи.

Пример запроса:<br>
{<br>
"url": "https://example.com",<br>
"max_depth": 3,<br>
"format": "graphml"<br>
}<br>
Пример ответа:<br>
{<br>
"task_id": "уникальный_идентификатор_задачи"<br>
}

@app.get("/parse_status")


Принимает идентификатор задачи и возвращает статус парсинга.

Пример запроса:<br>
GET /parse_status?task_id=уникальный_идентификатор_задачи<br>
Пример ответа:<br>
{<br>
"status": "completed",<br>
"progress": 100,<br>
"result": xml-графа<br>
}
